<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mi Universo Eres Tú</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Instrucciones */
        #ui-layer {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 1;
        }

        .instruction {
            color: rgba(100, 200, 255, 0.6);
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0, 100, 255, 0.5);
        }

        /* Etiquetas de los planetas */
        .planet-label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
            pointer-events: none;
            font-weight: bold;
        }

        /* Ventana Modal (Poemas) */
        #modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 5, 20, 0.6);
            /* Fondo semi-oscuro */
            z-index: 10;
            backdrop-filter: blur(5px);
            /* Efecto vidrio */
        }

        #modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 400px;
            background: linear-gradient(135deg, rgba(20, 0, 40, 0.95), rgba(0, 10, 40, 0.95));
            border: 1px solid #ff00de;
            box-shadow: 0 0 50px rgba(255, 0, 222, 0.3), inset 0 0 20px rgba(0, 255, 255, 0.1);
            padding: 30px;
            border-radius: 15px;
            color: #fff;
            text-align: center;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -40%);
            }

            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        h2 {
            margin-top: 0;
            color: #ff00de;
            text-shadow: 0 0 10px #ff00de;
            font-size: 24px;
        }

        p {
            font-size: 16px;
            line-height: 1.6;
            color: #e0e0ff;
            font-style: italic;
        }

        .author {
            display: block;
            margin-top: 15px;
            color: #00ffff;
            font-size: 12px;
            font-weight: bold;
            letter-spacing: 1px;
        }

        button {
            margin-top: 25px;
            padding: 10px 30px;
            background: transparent;
            border: 1px solid #00ffff;
            color: #00ffff;
            font-size: 14px;
            cursor: pointer;
            transition: 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        button:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 20px #00ffff;
        }

        #action-btn {
            display: none;
            /* Oculto por defecto */
            margin-right: 15px;
            background: rgba(255, 0, 222, 0.2);
            border-color: #ff00de;
            color: #ff00de;
        }

        #action-btn:hover {
            background: #ff00de;
            color: #fff;
            box-shadow: 0 0 20px #ff00de;
        }

        /* --- RESPONSIVE DESIGN (MÓVIL) --- */
        @media (max-width: 600px) {
            #modal-content {
                width: 85%;
                /* Más ancho en móvil */
                max-width: none;
                padding: 25px;
            }

            h2 {
                font-size: 28px;
                /* Título más grande */
            }

            p {
                font-size: 18px;
                /* Texto más legible */
            }

            .author {
                font-size: 14px;
            }

            button {
                width: 100%;
                /* Botones full width para facilitar el tap */
                margin: 10px 0 0 0;
                padding: 12px;
                font-size: 16px;
                display: block;
            }

            #action-btn {
                margin-right: 0;
            }

            .instruction {
                font-size: 12px;
                bottom: 20px;
                width: 90%;
                left: 5%;
            }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <div id="ui-layer">
        <div class="instruction">Explora nuestro universo • Toca el corazón • Toca los planetas</div>
    </div>

    <div id="modal-overlay">
        <div id="modal-content">
            <h2 id="m-title">Título</h2>
            <p id="m-body">Texto</p>
            <span class="author" id="m-author">Autor</span>
            <br>
            <button id="action-btn">Escuchar</button>
            <button id="close-btn">Cerrar</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // --- CONFIGURACIÓN DE CONTENIDO ---
        const SPOTIFY_URL = ""; // <--- PON TU LINK AQUÍ 

        const planetData = [
            {
                name: "Destino", color: 0x00d5ff, size: 1.5, dist: 22, speed: 0.003,
                poem: "Te cruzas en mi camino y se me olvida a dónde iba.", author: "Anon", ring: false
            },
            {
                name: "Tu Luz", color: 0xffaa00, size: 3.2, dist: 35, speed: 0.0015,
                poem: "Eres la luz que hace que mis sombras desaparezcan.", author: "P. Neruda", ring: true
            },
            {
                name: "Pasión", color: 0xff3366, size: 1.8, dist: 48, speed: 0.0022,
                poem: "El amor es la poesía de los sentidos.", author: "Balzac", ring: false
            },
            {
                name: "Eterno", color: 0xaa44ff, size: 2.5, dist: 65, speed: 0.001,
                poem: "Te amaré hasta que se apaguen las estrellas.", author: "Propio", ring: true
            },
            {
                name: "Sueño", color: 0x44ffaa, size: 2.0, dist: 80, speed: 0.0018,
                poem: "Eres mi sueño favorito del que no quiero despertar.", author: "Anon", ring: false
            },
            {
                name: "Magia", color: 0xff00ff, size: 1.2, dist: 95, speed: 0.0025,
                poem: "Hay magia en tu sonrisa que ilumina mi mundo.", author: "Anon", ring: true
            },
            {
                name: "Promesa", color: 0xffaa00, size: 2.8, dist: 110, speed: 0.0012,
                poem: "Juntos escribiremos nuestra propia historia.", author: "Anon", ring: false
            },
            {
                name: "Infinito", color: 0x00ccff, size: 3.5, dist: 125, speed: 0.0008,
                poem: "Mi amor por ti no tiene fin, es como el universo.", author: "Anon", ring: true
            },
            {
                name: "Destello", color: 0xffff00, size: 1.0, dist: 140, speed: 0.0005,
                poem: "Cada instante contigo es un destello de felicidad.", author: "Anon", ring: false
            }
        ];

        // --- ESCENA ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.002); // Niebla oscura

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 100); // Vista inicial más alejada

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0';
        document.body.appendChild(labelRenderer.domElement);

        const controls = new OrbitControls(camera, labelRenderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxDistance = 250;
        controls.minDistance = 20;
        controls.zoomSpeed = 2.0; // Zoom más rápido en celular

        // --- ILUMINACIÓN (Clave para el realismo de la foto) ---
        const ambientLight = new THREE.AmbientLight(0x111122, 1);
        scene.add(ambientLight);

        const sunLight = new THREE.PointLight(0xff00de, 3, 200); // Luz rosa fuerte desde el centro
        scene.add(sunLight);

        const blueLight = new THREE.PointLight(0x00ffff, 2, 100); // Luz de contra azul
        blueLight.position.set(20, 10, 20);
        scene.add(blueLight);

        // --- CREAR TEXTURA DE BRILLO (Procedural) ---
        function getGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 105, 180, 0.6)');
            gradient.addColorStop(1, 'rgba(232, 35, 100, 0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- EL CORAZÓN "CYBER" ---
        const heartGroup = new THREE.Group();
        scene.add(heartGroup);

        const shape = new THREE.Shape();
        const x = 0, y = 0;
        shape.moveTo(x + 5, y + 5);
        shape.bezierCurveTo(x + 5, y + 5, x + 4, y, x, y);
        shape.bezierCurveTo(x - 6, y, x - 6, y + 7, x - 6, y + 7);
        shape.bezierCurveTo(x - 6, y + 11, x - 3, y + 15.4, x + 5, y + 19);
        shape.bezierCurveTo(x + 12, y + 15.4, x + 16, y + 11, x + 16, y + 7);
        shape.bezierCurveTo(x + 16, y + 7, x + 16, y, x + 10, y);
        shape.bezierCurveTo(x + 7, y, x + 5, y + 5, x + 5, y + 5);

        const extrudeSettings = { depth: 4, bevelEnabled: true, bevelSegments: 3, steps: 2, bevelSize: 1, bevelThickness: 1 };
        const heartGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        heartGeo.center();

        // 1. Núcleo sólido brillante
        const coreMat = new THREE.MeshBasicMaterial({ color: 0xff0066 });
        const coreMesh = new THREE.Mesh(heartGeo, coreMat);
        coreMesh.scale.set(0.9, 0.9, 0.9); // Un poco más pequeño
        coreMesh.rotation.x = Math.PI;
        heartGroup.add(coreMesh);

        // 2. Malla de alambre (Grid) como en la foto
        const wireMat = new THREE.MeshBasicMaterial({ color: 0xffccff, wireframe: true, transparent: true, opacity: 0.5 });
        const wireMesh = new THREE.Mesh(heartGeo, wireMat);
        wireMesh.rotation.x = Math.PI;
        heartGroup.add(wireMesh);

        // 3. Aura gigante (Sprite)
        const glowSpriteMat = new THREE.SpriteMaterial({
            map: getGlowTexture(),
            color: 0xffffff,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false // Evita el "cuadro negro" al superponerse
        });
        const glowSprite = new THREE.Sprite(glowSpriteMat);
        glowSprite.scale.set(35, 35, 1);
        heartGroup.add(glowSprite);

        // --- FONDO DE ESTRELLAS Y NEBULOSAS ---
        const starGeo = new THREE.BufferGeometry();
        const starCount = 6000;
        const starPos = new Float32Array(starCount * 3);
        const starColors = new Float32Array(starCount * 3);

        for (let i = 0; i < starCount * 3; i += 3) {
            starPos[i] = (Math.random() - 0.5) * 400;
            starPos[i + 1] = (Math.random() - 0.5) * 200;
            starPos[i + 2] = (Math.random() - 0.5) * 400;

            // Colores azulados y rosados para las estrellas
            const mix = Math.random();
            starColors[i] = mix > 0.5 ? 0.5 : 1; // R
            starColors[i + 1] = mix > 0.5 ? 0.8 : 0.5; // G
            starColors[i + 2] = 1; // B
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        starGeo.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
        const starMat = new THREE.PointsMaterial({ size: 0.6, vertexColors: true, transparent: true, opacity: 0.8 });
        const starField = new THREE.Points(starGeo, starMat);
        scene.add(starField);

        // --- PLANETAS ---
        const planets = [];
        planetData.forEach(p => {
            const grp = new THREE.Group();
            scene.add(grp);

            const geo = new THREE.SphereGeometry(p.size, 32, 32);
            // Material físico para realismo
            const mat = new THREE.MeshStandardMaterial({
                color: p.color,
                roughness: 0.4,
                metalness: 0.3,
                emissive: p.color,
                emissiveIntensity: 1
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.x = p.dist;
            grp.add(mesh);

            // 4. Malla de alambre (Grid) como en el corazón
            const wireMat = new THREE.MeshBasicMaterial({
                color: 0xffffff, // Color blanco/claro para contraste
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            const wireMesh = new THREE.Mesh(geo, wireMat);
            wireMesh.scale.set(1.05, 1.05, 1.05); // Ligeramente más grande para que se vea
            mesh.add(wireMesh);

            // Anillo
            if (p.ring) {
                const ringGeo = new THREE.RingGeometry(p.size * 1.4, p.size * 2, 64);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.3 });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2.2;
                mesh.add(ring);
            }

            // Órbita visual (linea tenue)
            // Órbita visual (linea visible)
            const orbitCurve = new THREE.EllipseCurve(0, 0, p.dist, p.dist, 0, 2 * Math.PI, false, 0);
            const orbitPts = orbitCurve.getPoints(100);
            const orbitGeo = new THREE.BufferGeometry().setFromPoints(orbitPts);
            // Hacer la órbita más visible (color más claro, mayor opacidad)
            const orbitMat = new THREE.LineBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.3 });
            const orbitLine = new THREE.Line(orbitGeo, orbitMat);
            orbitLine.rotation.x = Math.PI / 2;
            scene.add(orbitLine);

            // Etiqueta HTML
            const div = document.createElement('div');
            div.className = 'planet-label';
            div.textContent = p.name;
            const label = new CSS2DObject(div);
            label.position.set(0, p.size + 1, 0);
            mesh.add(label);

            planets.push({ mesh: mesh, group: grp, data: p, angle: Math.random() * Math.PI * 2 });
        });

        // --- LÓGICA DE CLICS E INTERACCIÓN ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Elementos UI
        const modalOverlay = document.getElementById('modal-overlay');
        const mTitle = document.getElementById('m-title');
        const mBody = document.getElementById('m-body');
        const mAuthor = document.getElementById('m-author');
        const closeBtn = document.getElementById('close-btn');
        const actionBtn = document.getElementById('action-btn');

        // ESTADO GLOBAL: ¿Está el modal abierto?
        let isModalOpen = false;

        // Función para cerrar modal
        function closeModal() {
            modalOverlay.style.display = 'none';
            actionBtn.style.display = 'none'; // Resetear botón de acción
            // Aumentar delay para asegurar que no se cuele un click en el canvas
            setTimeout(() => { isModalOpen = false; }, 200);
        }

        actionBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            window.open(SPOTIFY_URL, '_blank');
            closeModal();
            // Asegurar que el estado se limpia
            setTimeout(() => { isModalOpen = false; }, 200);
        });

        closeBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Evita que el click pase al fondo
            closeModal();
        });

        // Click en el mundo 3D
        // Usar 'click' en lugar de 'pointerdown' para evitar conflictos con el arrastre de OrbitControls
        // Usar 'pointerdown' y 'pointerup' para detectar TAP (al levantar el dedo) sin conflicto con arrastre
        const pointerStart = new THREE.Vector2();

        window.addEventListener('pointerdown', (event) => {
            pointerStart.set(event.clientX, event.clientY);
        });

        window.addEventListener('pointerup', (event) => {
            // SI EL MODAL ESTÁ ABIERTO, IGNORAR
            if (isModalOpen) return;

            // Calcular distancia del movimiento (si arrastró la cámara, no es click)
            const distance = pointerStart.distanceTo(new THREE.Vector2(event.clientX, event.clientY));
            if (distance > 10) return; // Si movió más de 10px, es arrastre (rotación)

            // Calcular posición mouse
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // 1. Chequear Planetas
            const planetMeshes = planets.map(p => p.mesh);
            const intersects = raycaster.intersectObjects(planetMeshes, true); // Enable recursive to hit children (wireframe)

            if (intersects.length > 0) {
                const hitObj = intersects[0].object;
                // Find planet data checking if we hit the mesh itself or its child (wireframe is a child)
                const pData = planets.find(p => p.mesh === hitObj || p.mesh === hitObj.parent).data;

                // Abrir Modal
                mTitle.textContent = pData.name;
                mBody.textContent = pData.poem;
                mAuthor.textContent = pData.author;
                mAuthor.style.display = 'block'; // Mostrar autor
                actionBtn.style.display = 'none'; // No hay acción para planetas, solo lectura

                modalOverlay.style.display = 'block';
                isModalOpen = true; // ACTIVAR BLOQUEO
                return;
            }

            // 2. Chequear Corazón
            const intersectsHeart = raycaster.intersectObjects(heartGroup.children); // Detectar todo el grupo
            // Filtrar el sprite (aura) si es necesario, o dejarlo si queremos que el aura sea clickeable. 
            // Como el aura es transparente y depthWrite=false, es mejor ignorarlo para no bloquear.
            const heartHits = intersectsHeart.filter(hit => hit.object !== glowSprite);

            if (heartHits.length > 0) {
                // Abrir Modal para el corazón
                mTitle.textContent = "Nuestra Canción";
                mBody.textContent = "¿Quieres escuchar la canción que me recuerda a ti?";
                mAuthor.style.display = 'none'; // No mostrar autor

                actionBtn.textContent = "Sí, escuchar";
                actionBtn.style.display = 'inline-block'; // Mostrar botón de acción

                modalOverlay.style.display = 'block';
                isModalOpen = true;
            }
        });

        // --- ANIMACIÓN ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const time = Date.now() * 0.001;

            // Latido Corazón
            const scale = 1 + Math.sin(time * 3) * 0.05;
            heartGroup.scale.set(scale, scale, scale);
            heartGroup.rotation.y = Math.sin(time * 0.5) * 0.2;

            // Mover planetas (Si el modal está abierto, siguen moviéndose lento o normal)
            planets.forEach(p => {
                p.angle += p.data.speed;
                p.mesh.position.x = Math.cos(p.angle) * p.data.dist;
                p.mesh.position.z = Math.sin(p.angle) * p.data.dist;
                p.mesh.rotation.y += 0.01;
            });

            // Rotar estrellas - DESACTIVADO para que solo rote con interacción
            // starField.rotation.y += 0.0005;

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>

</html>